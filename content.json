{"pages":[{"title":"404","text":"","path":"404/index.html","date":"01-04","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"01-04","excerpt":""},{"title":"计算单数","text":"百分数转化小数 转化 转化为小数后 只需填写1,2,3,4选项,转化率填写为百分数转化后小数。 1,2为计算后的平均数以及对刷单的转化率。 3,4为商家店铺实际数据。 6为计算后达到预算需要的单数。 7为商家店铺实际的出售数量，可以作为比较数据。 8为要为商家提供的单数。 上级（同级平均）平均访客数: 上级（统计平均）转化率: 店铺（找你刷单的）的访客数: 店铺（找你刷单的）转化率: 计算 （同级平均）预计的刷单数: （找你刷单的）店铺实际单数: 你现在要给找你刷单的需要的刷单数: 7天计划总单数: 15天计划总单数:","path":"calculation/calculation.html","date":"01-04","excerpt":""},{"title":"","text":"#countbox { list-style: none; } #count,#go { width: 200px; height: 30px; border: none; background: #FF404073; } span{ display: inline-block; width: 300px; } input, textarea { background-color: transparent; color: #ff0000db; font-weight: bolder; }","path":"calculation/mycss.css","date":"01-07","excerpt":""},{"title":"","text":"function countone() { var count = document.getElementById('count') //计算按钮 count.onclick = function () { var visitorllerOne = document.getElementById('needvisitor').value, //获取需要的访客数 needconversion = document.getElementById('needconversion').value //预计转化率 quantityOne = document.getElementById('needquantity'), //获取预计刷单量 shopvisitorTwo = document.getElementById('shopvisitor').value, //获取店铺的访问量 shopConversion = document.getElementById('shopconversion').value, //获取店铺的转化率 quantityTwo = document.getElementById('shopquantity'), //获取店铺的实际销量 lastQuantity = document.getElementById('lastquantity'), //获取需要的刷单数 SevenTotal = document.getElementById('SevenTotal'); FifteenTotal = document.getElementById('FifteenTotal'); quantityOne.value = Math.round(visitorllerOne * needconversion) quantityTwo.value = Math.round(shopvisitorTwo * shopConversion) lastQuantity.value = quantityOne.value - quantityTwo.value SevenTotal.value = lastQuantity.value * 7 FifteenTotal.value = lastQuantity.value * 15 var num1 = SevenTotal.value; var num2 = 5; console.log((num1 - num2 * 7) / 7) console.log((num1 - num2 * 7) / 15) } } function countTwo() { var btn1 = document.getElementById('go') btn1.onclick = function () { var percent = document.getElementById('percent').value function toPoint(percent) { var str = percent.replace(\"%\", \"\"); str = str / 100; return str; } document.getElementById('result').value = toPoint(percent).toFixed(4); } } countone() countTwo()","path":"calculation/myjs.js","date":"01-07","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"01-04","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-04","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"01-04","excerpt":""}],"posts":[{"title":"利用gulp与npm创建自动化工具","text":"所需内容包查询地址 :https://gulpjs.com/plugins/gulp-less：将less文件内容编译成css内容。 gulp-cssnano：压缩css文件内容 gulp-htmlmin：压缩HTML文件内容 gulp-uglify：压缩混淆JS文件内容 gulp-connect：创建一个开发阶段所使用的服务器 这些方法都可以通过 npm/cnpm install 进行安装 特殊方法介绍gulp-htmlmin 链接:https://www.npmjs.com/package/connect12345678const gulp = require('gulp');const htmlmin = require('gulp-htmlmin'); gulp.task('minify', () =&gt; &#123; return gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(gulp.dest('dist'));&#125;); gulp-connect1234567891011121314151617181920212223242526var connect = require('connect');var http = require('http'); var app = connect(); // gzip/deflate outgoing responsesvar compression = require('compression');app.use(compression()); // store session state in browser cookievar cookieSession = require('cookie-session');app.use(cookieSession(&#123; keys: ['secret1', 'secret2']&#125;)); // parse urlencoded request bodies into req.bodyvar bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;)); // respond to all requestsapp.use(function(req, res)&#123; res.end('Hello from Connect!\\n');&#125;); //create node.js http server and listen on porthttp.createServer(app).listen(3000); 具体实现导入所需包12345const &#123; src, dest ,watch,series&#125; = require(\"gulp\")const htmlmin = require(\"gulp-htmlmin\");const uglify = require(\"gulp-uglify\")const cssnano = require(\"gulp-cssnano\")const connect=require(\"gulp-connect\") 压缩HTML网页1234567function htmlmini() &#123; return src(\"src/*.html\") .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(dest(\"dest/\"))&#125; exports.htmlmn = htmlmini 压缩JS12345678function scriptmini() &#123; return src(\"src/*.js\") .pipe(uglify()) .pipe(dest(\"dest/\")) &#125; exports.scriptmn = scriptmini 压缩css1234567function cssmini() &#123; return src(\"src/*.css\") .pipe(cssnano()) .pipe(dest(\"dest/\")) &#125;exports.cssmn=cssmini 1234567function watchfile(cb)&#123; watch(\"src/*.html\",htmlmini) watch(\"src/*.js\",scriptmini) watch(\"src/*.css\",cssmini) cb()&#125;exports.watch=watchfile 创建本地服务器123456789function serverauto(cb)&#123; connect.server(&#123; root: \"dest\", port: 4000, livereload:true &#125;) cb()&#125;exports.servermn=serverauto 当服务器与自动化任务创建完成之后就可以通过series方法绑定为默认方法。1exports.default =series(watchfile,serverauto) 所有的内容均在nood.js中执行文件，HTML/CSS/JS的编写在vscode中进行编辑，保存。 当方法没有return时，需要通过传入回调函数进行执行，否则会出错。","path":"2019/01/08/利用gulp与npm创建对网页内容的编辑刷新自动化/","date":"01-08","excerpt":"","tags":[{"name":"nood.js","slug":"nood-js","permalink":"https://bmmanmyt.github.io/tags/nood-js/"}]},{"title":"gulp","text":"gulp :自动化构建工具入门指南 全局安装 gulp： $ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： $ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： var gulp = require(&apos;gulp&apos;); gulp.task(&apos;default&apos;, function() { // 将你的默认的任务代码放在这 }); 运行 gulp： $ gulp API文档：gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。1234gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) .pipe(gulp.dest('build/minified_templates')); 通俗来讲gulp就像一条生产线,src将需要生产的物品放进来,通过pipe()进行运输包装（pipe中调用的方法）,完成之后再通过最后的dest()放入产品的仓库。 常用的API有:src() :从文件系统中读取对象 dest() :将创建的文件写入文件系统 watch() :观察全局并在发生改变时运行任务 API具体网址：https://gulpjs.com/docs/en/api/concepts","path":"2019/01/07/gulp自动化构建工具/","date":"01-07","excerpt":"","tags":[{"name":"nood.js","slug":"nood-js","permalink":"https://bmmanmyt.github.io/tags/nood-js/"}]},{"title":"npm管理器","text":"NPM: NPM是随同NodeJS一起安装的包管理工具为了安装第三包，需要用nom管理器。第三方平台下载 : https://www.npmjs.com/ 安装npm :npm init 创建之后，在package.json中加入private：true代表设置为私人的包，并不会公众化。 安装第三方包npm install --global http-server 安装全局http命令。 默认为最新版本，在server后@可设置版本号。 npm uninstall --global http-server 卸载全局http命令 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 npm install –global gulp安装本地包 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 npm install gulp –save-dev/-D 适用于开发阶段的包 –save 适用于开发和产品阶段 卸载模块我们可以使用以下命令来卸载 Node.js 模块。 $ npm uninstall express卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看： $ npm ls 更新模块我们可以使用以下命令更新模块： $ npm update express 搜索模块使用以下来搜索模块： $ npm search express 创建模块创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。1234567891011121314151617181920212223242526272829303132$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt; --save` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.name: (node_modules) runoob # 模块名version: (1.0.0) description: Node.js 测试模块(www.runoob.com) # 描述entry point: (index.js) test command: make testgit repository: https://github.com/runoob/runoob.git # Github 地址keywords: author: license: (ISC) About to write to ……/node_modules/package.json: # 生成地址&#123; \"name\": \"runoob\", \"version\": \"1.0.0\", \"description\": \"Node.js 测试模块(www.runoob.com)\", ……&#125;Is this ok? (yes) yes以上的信息，你需要根据你自己的情况输入。在最后输入 \"yes\" 后会生成 package.json 文件。 注册用户（使用邮箱注册）：$ npm adduserUsername: mcmohdPassword:Email: (this IS public) mcmohd@gmail.com 发布模块：$ npm publish如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。 NPM 常用命令除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help 可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 解决服务器在国外下载慢的问题。方法一淘宝定制命令行工具 npm install -g cnpm --registry=https://registry.npm.taobao.org 方法二修改npm的下载仓库为淘宝镜像 npm config set registry http://registry.npm.taobao.org/ 如果要发布自己的镜像需要修改回来 npm config set registry https://registry.npmjs.org/","path":"2019/01/07/npm第三方包管理器/","date":"01-07","excerpt":"","tags":[{"name":"nood.js","slug":"nood-js","permalink":"https://bmmanmyt.github.io/tags/nood-js/"}]},{"title":"Commonjs","text":"Commonjs规范介绍：CommonJS定义的模块分为: 1.模块引用(require) 2.模块定义(exports) 3.模块标识(module) CommonJs规范的出发点：JS没有模块系统、标准库较少、缺乏包管理工具；为了让JS可以在任何地方运行，以达到Java、C#、PHP这些后台语言具备开发大型应用的能力； 在CommonJs规范中：1一个文件就是一个模块，拥有单独的作用域； 2普通方式定义的变量、函数、对象都属于该模块内； 3通过require来加载模块； 4通过exports和modul.exports来暴露模块中的内容； ps :所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的; exports 导出require 导入每个模块内部都有一个module对象，代表当前对象。 123456exports.multiply = function(num1, num2) &#123; return num1 * num2; &#125;exports.divide = function(num1, num2) &#123; return num1 / num2; &#125; module变量： 每个模块内部都有一个module对象，代表着当前模块。它有以下属性： 12345console.log(module.id) // 模块的标识符，通常是带有绝对路径的模块文件名 console.log(module.filename) // 模块文件名，带有绝对路径 console.log(module.parent) // 调用该模块的模块 console.log(module.chilren) // 该模块调用的模块 console.log(module.exports) // 表示模块对外导出的值 exports变量： 为了方便，Node为每个模块提供了exports变量，指向module.exports， 等同于： var exports = module.exports（Node隐式做了这个赋值） 这样做的好处是，在对外输出模块接口时，可以向exports对象添加方法暴露出去。因此如果改变了module.exports，但还想使用export.xxx的方式暴露一些东西，那就只好我们自己来写exports = module.exports; console.log(exports)123module.exports = songthing;//接下来把exports指回来exports = module.exports;//常见写法是：exports = module.exports = something; 基本用法导出module1.js模块中内容： 1234567exports.multiply = function(num1, num2) &#123;return num1 * num2;&#125;exports.divide = function(num1, num2) &#123;return num1 / num2;&#125; 导入module1.js模块中的内容： 123456const module1 = require(&apos;./module1.js&apos;);console.log(module1.multiply(3, 4))console.log(module1.divide(12, 4))&#125; 常用命令已经标识符__dirname代表当前模块文件所在的文件夹路径 __filename代表当前模块文件所在的文件夹路径+文件名 npm root -g：查看npm全局包安装位置，建议在nvm目录下新建npm\\node_modules目录，然后设置npm的全局包安装位置：npm config set prefix “”，然后将该路径添加到环境变量中; npm init -y：初始化一个package.json文件，加上-y就会默认生成该文件，无需一步一步填写；npm docs 包名：查看包的文档；npm install：安装package.json中dependencies属性中所有依赖的包","path":"2019/01/07/Commonjs规范/","date":"01-07","excerpt":"","tags":[{"name":"模块化","slug":"模块化","permalink":"https://bmmanmyt.github.io/tags/模块化/"}]},{"title":"node.js简单介绍","text":"介绍简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 中文API文档： http://nodejs.cn/api/英文API文档: https://nodejs.org/en/docs/命令与特殊键1234567891011121314node 进入交互式解析node --help 帮助信息node -v 版本信息-e 执行JS代码.break 终止正在输入的表达式.load 读取一个文件到当前会话.editor 进入编辑模式","path":"2019/01/07/node-js介绍/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"箭头函数","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;pre style=\"color:red\"&gt; // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ &lt;/pre&gt; &lt;script&gt; /* **************************************************************** */ /* var 声明的变量会被提升，多次声明时会被覆盖。 let 声明的变量不会被提升，不可以多次声明，作用于只存在于块。 */ /* **************************************************************** */ // 使用const可以声明常量，常量不可以被更改。 /* **************************************************************** */ // 函数参数的默认值，当函数不传入参数时显示的默认值 function MY(name = \"李四\", age = \"20\") &#123; return name + age &#125; console.log(MY()) console.log(MY(\"王五\", \"15\")) /* **************************************************************** */ // 箭头函数 // 箭头函数中没有this，this的指向是windows var num = (a, b) =&gt; a + b //有两个参数 console.log(num(3, 4)) var a = () =&gt; \"hi\" //没有参数 console.log(a()) var b = name =&gt; name //只有一个参数 console.log(b(\"渣男\")) var num2 = (c, d) =&gt; c &gt; d ? c : d //两个数比较大小 console.log(num2(5, 7)) /* **************************************************************** */ //剩余操作符(...) //1.用于传入参数时不知道参数个数。 var e = (...f) =&gt; f console.log(e(1, 2, 3, 4, 5, 6, 7, 8, 9)) //测试，乘 加： var resule = (operator, ...numall) =&gt; &#123; if (operator === \"+\") &#123; let resule1 = 0 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 += numall[i] &#125; return resule1 &#125; if (operator === \"*\") &#123; let resule1 = 1 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 *= numall[i] &#125; return resule1 &#125; &#125; console.log(resule(\"+\", 1, 2, 3, 4)) console.log(resule(\"*\", 1, 2, 3, 4)) //2.用于展开数组 let arr1 = [1, 2, 3, 4, 5, 67, 8, 9, 7] console.log(...arr1) // 3.复制数组 let arr2 = [...arr1] console.log(arr2) /* **************************************************************** */ // 模板字面量 console.log(` --------------- --------------- || || --------------- --------------- || || --------------- --------------- 中间拼接变量时用$() `) console.log(` // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ `) /* **************************************************************** */ // 对象属性的简写 // 对象的属性名字==属性值的时候，可以只写一个。 let g = \"渣男\" var obj = &#123; g &#125; console.log(obj.g) /* **************************************************************** */ //数据解构 let munber = [1, 2, 3, 4, 56, 7, 8, 9, 5] let [one, ...two] = munber console.log(one, two) let munber2 = [1, 2, 3, [4, 56, 7], 8, 9, 5] let [, , , [thiree]] = munber2 console.log(thiree) /* **************************************************************** */ //对象解构 let h = &#123; name: \"mengmeng\" &#125; let &#123; name &#125; = h console.log(name) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"2019/01/05/箭头函数/","date":"01-05","excerpt":"","tags":[{"name":"ES6新特性","slug":"ES6新特性","permalink":"https://bmmanmyt.github.io/tags/ES6新特性/"}]},{"title":"JavaScript 简答题","text":"请描述一下cookies，sessionStorage和localStorage的区别？sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 看下列代码输出为何？解释原因。123var a;alert(typeof a); // undefinedalert(b); // 报错 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。1234567891011121314151617181920212223function randomNub(aArray, len, min, max) &#123; if (len &gt;= (max - min)) &#123; return '超过' + min + '-' + max + '之间的个数范围' + (max - min - 1) + '个的总数'; &#125; if (aArray.length &gt;= len) &#123; aArray.sort(function(a, b) &#123; return a - b &#125;); return aArray; &#125; var nowNub = parseInt(Math.random() * (max - min - 1)) + (min + 1); for (var j = 0; j &lt; aArray.length; j++) &#123; if (nowNub == aArray[j]) &#123; randomNub(aArray, len, min, max); return; &#125; &#125; aArray.push(nowNub); randomNub(aArray, len, min, max); return aArray; &#125;var arr=[];randomNub(arr,10,10,100); 如何阻止事件冒泡和默认事件阻止事件冒泡：1234.stopPropagation();// 阻止默认事件return false;.preventDefault(); JavaScript的数据类型都有什么？看下列代码，将会输出什么?(变量声明提升)123456var foo = 1;(function()&#123; console.log(foo); // undefined var foo = 2; console.log(foo); // 2&#125;)() 怎样添加、移除、移动、复制、创建和查找节点。正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？当使用RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\表示一个\\）。使用正则表达字面量的效率更高。邮箱的正则匹配： var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/; 一个完整的URL有哪几部分组成？1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。 2.域名部分：该URL的域名部分为“www.haogu.com”。一个URL中，也可以使用IP地址作为域名使用。 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“username=lisi&amp;password=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 请求消息和相应消息分别有哪几本部分组成？客户端发送给服务器端的HTTP请求消息由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，如下图所示。 123456789GET /index.html HTTP/1.1 Host: www.baidu.com Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie:BAIDUID=002E605A2EE0AA27D0B7C2295B9D0242:FG=1;BIDUPSID=002E605A2EE0AA27D0B7C2295B9D0242;PSTM=1532306024;BD_UPN=12314753;BDORZ=B490B5EBF6F3CD402E515D22BCDA1598;delPer=0;BD_HOME=0;H_PS_PSSID=1465_26911_21121_26350_26925_20719 第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本. 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。GET指定请求类型为GET，/index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 从第二行起为请求头部，HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等。 第三部分：空行，请求头部后面的空行是必须要有的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request：123456789101112131415POST /api/students HTTP/1.1 Host: 192.168.0.130:3000 Connection: keep-alive Content-Length: 245 Cache-Control: max-age=0 Origin: http://192.168.0.130:3000 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://192.168.0.130:3000/students/create Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9clazz=%E7%81%AB%E8%8A%B112%E6%9C%9F&amp;name=%E9%99%88%E6%A2%A6%E9%BE%99&amp;gender=%E7%94%B7&amp;age=20&amp;hobby=%E7%9D%A1%E8%A7%89&amp;hobby=%E6%89%93%E8%B1%86%E8%B1%86&amp;tel=13834569928&amp;address=%E5%8D%97%E9%98%B3&amp;remark=%E6%96%B0%E5%90%8C%E5%AD%A6&amp;date=2018-08-01 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 响应消息Response一般情况下，服务器接收到请求后，会对请求进行处理，然会返回给客户端一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。1234567891011121314151617181920212223242526272829HTTP/1.1 200 OK Bdpagetype: 1 Bdqid: 0xc347763400004282 Cache-Control: private Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html Cxy_all: baidu+5e802392ce41b42ad2771898f1006759 Date: Thu, 09 Aug 2018 01:36:14 GMT Expires: Thu, 09 Aug 2018 01:36:06 GMT Server: BWS/1.1 Set-Cookie: delPer=0; expires=Sat, 01-Aug-2048 01:36:06 GMT Set-Cookie: BDSVRTM=0; path=/ Set-Cookie: BD_HOME=0; path=/ Set-Cookie: H_PS_PSSID=1465_26964_21121_26350_26925_20719;path=/;domain=.baidu.com Strict-Transport-Security: max-age=172800 Vary: Accept-Encoding X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;百度一下&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档内容。。。&lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 空行后面的html部分为响应正文。 HTTP协议的工作原理？HTTP请求的方式有几种？分别表示什么意义？有 8 种；HTTP 1.0 提供了 GET，POST，HEAD；HTTP 1.1 有新增了 OPTIONS，PUT，DELETE，CONNECT，TRACE Ajax 的作用是什么? 如何创建一个Ajax？作用：用于浏览器与服务器进行数据交互，实现页面的局部刷新。 ######## 创建一个Ajax请求：12345678Var request = XMLHttpRequest();request.open(‘POST’, url, true); // 默认是异步请求request.onreadystatechange = function()&#123;&#125;;// 设置请求头request.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);request.send(null); 举例描述同步和异步的区别？同步:发送一个请求,等待返回,然后再发送下一个请求异步:发送一个请求,不等待返回,随时可以再发送下一个请求 请简述一下什么是同源策略？同源策略浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说浏览器禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 什么是同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 如何解决跨域问题？1.JSONP2.通过服务器进行设置3.使用代理服务器 请简述GET和POST请求的区别，以及它们的使用场景？安全性GET 请求会将传输数据拼接在 URL 中，并显示在浏览器地址栏中。而POST相对来说比较安全，传输的数据会被放到请求体中。 传输速度GET请求会被POST请求快一些。 传输数据量GET请求能传输的数据量比较小，因不同的浏览器而有所不同，大概 4KB左右；而POST请求能传输的数据理论上没有上限的，但由于服务器硬件资源的限制，能传输的数据量也会受影响。有时候服务器的设置也会影响能传输的数据量。 在进行Ajax请求时，如何解析请求返回的json数据使用JSON.parse()方法将json格式的字符串转换成对象（Array或Object）列举出你学过的JavaScript本地对象，内置对象和宿主对象本地对象：Object, Array,Date内置对象：global,Math宿主对象：DOM，BOM 请分别描述引用类型的数据和基本类型的数据在内存中的存储方式？基本类型的数据直接存储在变量的存储空间中；而引用类型的数据并没直接存储在变量的存储空间中，变量中存储的只是引用类型数据所在的内存地址。 在使用new操作符调用函数时，具体发生了什么事（new操作符的作用）?当我们使用 new 操作符调用函数时，函数内部会自动创建一个该类型的新对象，新对象的原型指向构造函数的prototype属性。当函数调用完成时，该对象会被自动的返回到函数外部。我们可以在函数内部通过 this 关键字使用新创建的对象。 对象的属性有几种类型？怎么定义这些属性？有 2 种，分别是：数据属性和访问器属性；定义属性的方式如下：123456789101112131415161718192021Var obj1 = &#123;Name: ‘张铭恩’Age: 20,Get adult() &#123;Return this.age &gt;= 18 ? true : false;&#125;&#125;Var obj2 = &#123;Name: ‘张铭恩’Age: 20,Count: 20000Get money() &#123;Return this.count / 100;&#125;,Set money(income) &#123;This.count = this.count + income * 100;&#125;&#125;Obj2.money; // 200;// 收入300Obj2.money = 300; 属性的特性有哪些？分别代表什么意思？数据属性的特性：value 属性值Writable 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除访问器属性的特性：Get 是否可以访问Set 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除 怎样获取属性的特性？怎样设置属性的特性？获取属性的特性：getOwnPropertyDescriptor()getOwnPropertyDescriptors()设置属性的特性:defineProperty()defineProperties() 怎样封印、冻结和禁止对象扩展？禁止扩展：preventExtensions();封印对象：seal()冻结对象：freeze()被禁止扩展对象、被封印对象和被冻结对象有什么特点？被禁止扩展对象的特点： 不能添加新属性（不可扩展） 可以删除已有属性 可以修改已有属性的值 被封印对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 可以修改已有属性的值被冻结对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 不能修改已有属性的值请简述对象属性的查找顺序？当我方法对象的属性时，JavaScript引擎首先会去对象自身的属性列表种查询，如果有，则返回；如果没有，则沿着原型对象链向下寻找。如果整个原型对象链中都没有，则返回 undefined。对象的继承方式有几种？请分别编程实现：3 种，分别是：原型对象继承、对象继承、构造函数继承；12345678910111213141516171819202122232425262728293031323334原型继承（JS默认继承方式）：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;var rect = new Rectangle(40, 20);rect 对象默认继承了 Rectangle.prototype，间接继承了 Object.prototype。对象继承：var obj1 = &#123;...&#125;;var obj2 = Object.create(obj1, &#123;...&#125;);obj2 继承了 obj1，obj1继承 Object.prototype。构造函数继承：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;Object.defineProperty(Rectangle.prototype, ‘getArea’, &#123;value: function()&#123;return this.width * this.height;&#125;Writable: false,Enumerable: false,Configurable: false&#125;);function Square(w)&#123;this.width = w;this.height = w;&#125;Square.prototype = Object.create(new Rectangle(), &#123;constructor: &#123;value: Square,configurable: false,enumerable: false,writable: false&#125;&#125;&#125;;","path":"2019/01/04/JavaScript-简答题/","date":"01-04","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bmmanmyt.github.io/tags/JavaScript/"}]}]}