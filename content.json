{"pages":[{"title":"","text":"#countbox { list-style: none; } #count,#go { width: 200px; height: 30px; border: none; background: #FF404073; } span{ display: inline-block; width: 300px; } input, textarea { background-color: transparent; color: #ff0000db; font-weight: bolder; }","path":"calculation/mycss.css","date":"01-11","excerpt":""},{"title":"计算单数","text":"百分数转化小数 转化 转化为小数后 只需填写1,2,3,4选项,转化率填写为百分数转化后小数。 1,2为计算后的平均数以及对刷单的转化率。 3,4为商家店铺实际数据。 6为计算后达到预算需要的单数。 7为商家店铺实际的出售数量，可以作为比较数据。 8为要为商家提供的单数。 上级（同级平均）平均访客数: 上级（统计平均）转化率: 店铺（找你刷单的）的访客数: 店铺（找你刷单的）转化率: 计算 （同级平均）预计的刷单数: （找你刷单的）店铺实际单数: 你现在要给找你刷单的需要的刷单数: 7天计划总单数: 15天计划总单数:","path":"calculation/calculation.html","date":"01-04","excerpt":""},{"title":"关于我","text":"","path":"about/index.html","date":"01-04","excerpt":""},{"title":"标签","text":"","path":"tags/index.html","date":"01-04","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"01-04","excerpt":""},{"title":"分类","text":"","path":"categories/index.html","date":"01-04","excerpt":""},{"title":"404","text":"","path":"404/index.html","date":"01-04","excerpt":""},{"title":"","text":"function countone() { var count = document.getElementById('count') //计算按钮 count.onclick = function () { var visitorllerOne = document.getElementById('needvisitor').value, //获取需要的访客数 needconversion = document.getElementById('needconversion').value //预计转化率 quantityOne = document.getElementById('needquantity'), //获取预计刷单量 shopvisitorTwo = document.getElementById('shopvisitor').value, //获取店铺的访问量 shopConversion = document.getElementById('shopconversion').value, //获取店铺的转化率 quantityTwo = document.getElementById('shopquantity'), //获取店铺的实际销量 lastQuantity = document.getElementById('lastquantity'), //获取需要的刷单数 SevenTotal = document.getElementById('SevenTotal'); FifteenTotal = document.getElementById('FifteenTotal'); quantityOne.value = Math.round(visitorllerOne * needconversion) quantityTwo.value = Math.round(shopvisitorTwo * shopConversion) lastQuantity.value = quantityOne.value - quantityTwo.value SevenTotal.value = lastQuantity.value * 7 FifteenTotal.value = lastQuantity.value * 15 var num1 = SevenTotal.value; var num2 = 5; console.log((num1 - num2 * 7) / 7) console.log((num1 - num2 * 7) / 15) } } function countTwo() { var btn1 = document.getElementById('go') btn1.onclick = function () { var percent = document.getElementById('percent').value function toPoint(percent) { var str = percent.replace(\"%\", \"\"); str = str / 100; return str; } document.getElementById('result').value = toPoint(percent).toFixed(4); } } countone() countTwo()","path":"calculation/myjs.js","date":"01-11","excerpt":""}],"posts":[{"title":"express结构具体分析","text":"","path":"2019/01/10/express入门/","date":"01-10","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"Less入门","text":"为什么要有预处理CSSCSS基本上是设计师的工具，不是程序员的工具。在程序员的眼里，CSS是很头痛的事情，它并不像其它程序语言，比如说PHP、Javascript等等，有自己的变量、常量、条件语句以及一些编程语法，只是一行行单纯的属性描述，写起来相当的费事，而且代码难易组织和维护。 很自然的，有人就开始在想，能不能给CSS像其他程序语言一样，加入一些编程元素，让CSS能像其他程序语言一样可以做一些预定的处理。这样一来，就有了“CSS预处语言（CSS Preprocessor）”。 CSS预处理器定义了一种新的语言，其基本思想是，用一种专门的编程语言，为CSS增加了一些编程的特性，将CSS作为目标生成文件，然后开发者就只要使用这种语言进行编码工作。通俗的说，CSS预处理器用一种专门的编程语言，进行Web页面样式设计，然后再编译成正常的CSS文件，以供项目使用。CSS预处理器为CSS增加一些编程的特性，无需考虑浏览器的兼容性问题，例如你可以在CSS中使用变量、简单的逻辑程序、函数等等在编程语言中的一些基本特性，可以让你的CSS更加简洁、适应性更强、可读性更佳，更易于代码的维护等诸多好处。 CSS预处理器技术已经非常的成熟，而且也涌现出了很多种不同的CSS预处理器语言，比如说：Sass（SCSS）、LESS、Stylus、Turbine、Swithch CSS、CSS Cacheer、DT CSS等。如此之多的CSS预处理器，那么“我应该选择哪种CSS预处理器？”也相应成了最近网上的一大热门话题，在Linkedin、Twitter、CSS-Trick、知呼以及各大技术论坛上，很多人为此争论不休。相比过计我们对是否应该使用CSS预处理器的话题而言，这已经是很大的进步了。 到目前为止，在众多优秀的CSS预处理器语言中就属Sass、LESS和Stylus最优秀，讨论的也多，对比的也多。相信前端开发工程师会做出自己的选择——我要选择哪款CSS预处理器语言。 如何使用LessLess不能在客户端直接执行，需要转换成标准的CSS语法。下面列出了几种Less的使用方法： 命令行 a. 安装Less 1$ npm install -g less b. 使用lessc（compiler）将less文件编译成CSS，默认输出到控制台 1$ lessc styles.less c. 编译Less文件，输出到指定文件： 1$ lessc styles.less styles.css 客户端（不推荐使用） a. 通过&lt;link&gt;标签引入Less文件 1&lt;link rel=\"stylesheet/less\" type=\"text/css\" href=\"styles.less\" /&gt; b. 下载less.js文件，在&lt;head&gt;标签中通过&lt;script&gt;标签引入less.js文件。 1&lt;script src=\"less.js\" type=\"text/javascript\"&gt;&lt;/script&gt; 使用gulp自动编译less文件 a. 初始化项目 1npm init b. 安装gulp 1npm install gulp --save-dev c. 创建gulpfile.js文件 d. 创建编译less文件的任务 Less基础语法Less（Leaner Style Sheets）一种 CSS 扩展， 不仅向后兼容 CSS语法，它还为现有的 CSS 语法新增了额外的特性。下面我们就来讲述如何使用Less的基础语法。 注释行注释和块注释： 1234567/* 多行注释@var: white;@var: red;*/// 单行注释// @var: white;// @var: red; 变量顾名思义： 123456@nice-blue: #5B83AD;@light-blue: @nice-blue + #111;#header &#123; color: @light-blue;&#125; 输出结果： 123#header &#123; color: #6c94be;&#125; 混合混合是一种将一组属性从一个规则集引入（混入）到另一个规则集中的方式。 假设我们有以下样式: 1234.bordered &#123; border-top: dotted 1px black; border-bottom: solid 2px black;&#125; 我们希望在其他规则集内部使用上面这些属性，那么，我们只需要访问我们想要的属性所在类的名称即可，就像下面这样： 123456789#menu a &#123; color: #111; .bordered;&#125;.post a &#123; color: red; .bordered;&#125; 编译后，.bordered规则集中的属性就会同时出现在#menu a和.post a规则集中了（注意，也可以将ID选择器作为混入对象）。 1234567891011#menu a &#123; color: #111; border-top: dotted 1px black; border-bottom: solid 2px black;&#125;.post a &#123; color: red; border-top: dotted 1px black; border-bottom: solid 2px black;&#125; 嵌套Less给我们提供了嵌套的功能，用来代替级联选择器。假设我们有以下CSS： 123456789#header &#123; color: black;&#125;#header .navigation &#123; font-size: 12px;&#125;#header .logo &#123; width: 300px;&#125; 在 Less 中，我们可以使用下面这种方式编写: 123456789#header &#123; color: black; .navigation &#123; font-size: 12px; &#125; .logo &#123; width: 300px; &#125;&#125; 这样的代码更简洁, 它模仿了 HTML 的结构。 使用这种方法照样可以在 mixins 中包含伪类(pseudo-selectors)。下面是一个经典的 clearfix 代码，在这里使用 mixins 重写了（&amp; 表示当前选择器的父选择器）： 12345678910111213.clearfix &#123; display: block; zoom: 1; &amp;:after &#123; content: \" \"; display: block; font-size: 0; height: 0; clear: both; visibility: hidden; &#125;&#125; 嵌套指令和冒泡 像@media或@supports这样的指令可以像选择器一样嵌套。最终指令会被提升到外部，与同一个规则集中的其他元素的相对顺序保持不变。这被称为冒泡。 123456789101112.component &#123; width: 300px; @media (min-width: 768px) &#123; width: 600px; @media (min-resolution: 192dpi) &#123; background-image: url(/img/retina2x.png); &#125; &#125; @media (min-width: 1280px) &#123; width: 800px; &#125;&#125; 编译输出： 123456789101112131415161718.component &#123; width: 300px;&#125;@media (min-width: 768px) &#123; .component &#123; width: 600px; &#125;&#125;@media (min-width: 768px) and (min-resolution: 192dpi) &#123; .component &#123; background-image: url(/img/retina2x.png); &#125;&#125;@media (min-width: 1280px) &#123; .component &#123; width: 800px; &#125;&#125; 操作符算术运算符可以操作任何数字，颜色，或变量。在进行加、减或比较之前会先将它们的转换成相同的单位。计算结果的单位和左边操作数保持一致。如果单位之间不能转换，或没有意义，则单位会被忽略。不能转换的例子如：px转换成cm或rad转换成%。 1234567891011// 数字被传换成相同的单位@conversion-1: 5cm + 10mm; // 6cm@conversion-2: 2 - 3cm - 5mm; // -1.5cm// 不能转换@incompatible-units: 2 + 5px - 3cm; // result is 4px// 变量参与运算@base: 5%;@filler: @base * 2; // 10%@other: @base + @filler; // 15% * 和 / 操作不会进行单位转换。大多数情况下没有意义，比如，长度乘以长度得面积，而CSS不支持指定面积。 1@base: 2cm * 3mm; // result is 6cm 你也可以计算颜色值： 12@color: #224488 / 2; // #112244background-color: #112244 + #111; // #223355 然而，你可能会发现Less的颜色函数（专门处理颜色的函数）会更有用。 转义转义允许您使用任何任意字符串作为属性或变量值。在~&quot;anything&quot;中的任何东西都是按照原样使用的，除了插值以外没有任何变化。 1234567@min768: ~\"(min-width: 768px)\"; // 或者 ~'(min-width: 768px)'.element &#123; @media @min768 &#123; font-size: 1.2rem; &#125;&#125; 编译输出： 12345@media (min-width: 768px) &#123; .element &#123; font-size: 1.2rem; &#125;&#125; 函数Less 提供了许多用于转换颜色，处理字符串和进行算术运算的函数。他们在函数参考一节有详细的的介绍。 这些函数使用起来非常简单。在下面的例子中我们使用 percentage 将 0.5 转换为 50%，然后将基础颜色值的饱和度增加了 5%，最后将背景颜色的亮度增加了 25% 之后又将色相值增加 8: 12345678@base: #f04615;@width: 0.5;.class &#123; width: percentage(@width); // 返回 `50%` color: saturate(@base, 5%); background-color: spin(lighten(@base, 25%), 8);&#125; 命名空间和访问器有时候，为了更好地组织代码，你可能会想要将 mixins 进行分组，或包裹起来。在 Less 中做到这一点非常直观，假设你想在 #bundle 下捆绑一些 mixins 和变量，以便稍候复用或者编译输出： 123456789101112#bundle() &#123; .button &#123; display: block; border: 1px solid black; background-color: grey; &amp;:hover &#123; background-color: white &#125; &#125; .tab &#123; ... &#125; .citation &#123; ... &#125;&#125; 现在，如果我们想把.button规则集中的属性混和到#header a规则集中，我们可以这样做： 1234#header a &#123; color: orange; #bundle &gt; .button; // 也可以写成 #bundle.button&#125; 注意：如果你不想让命名空间中的代码编译输出到你的CSS中，比如，#bundle .tab，那么在命名空间之后添加一个括号()就可以了。 命名空间中声明的变量，在空间外部是不可用的。但是你可以使用上面的语法引用空间中的 mixins（#bundle &gt; .mixin-name）。因此，你不能这么做：#bundle &gt; @variable-name。 作用域Less 中的作用域与编程语言中的作用域概念非常相似。首先会在局部查找变量和 mixins，如果没找到，编译器就会在父作用域中查找，依次类推。 12345678@var: red;#page &#123; @var: white; #header &#123; color: @var; // white &#125;&#125; 变量和 mixins 在使用之前不必先定义。因此下面的代码与前面的例子等价： 12345678@var: red;#page &#123; #header &#123; color: @var; // white &#125; @var: white;&#125; 导入导入工作和预想的一样。你可以导入一个.less文件，然后这个文件中的所有变量都可以使用了。如果导入的是.less文件，则文件的扩展名是可选的。 12@import \"library\"; // library.less@import \"typo.css\";","path":"2019/01/10/Less入门/","date":"01-10","excerpt":"","tags":[{"name":"CSS进阶","slug":"CSS进阶","permalink":"https://bmmanmyt.github.io/tags/CSS进阶/"}]},{"title":"node.js搭建服务器——前后端分离","text":"使用node.JS搭建服务器实战Express是一个基于NodeJS平台的Web框架。 首先假定你已经安装了 Node.js，接下来为你的应用创建一个目录，然后进入此目录并将其作为当前工作目录。 $ mkdir myapp $ cd myapp 通过 npm init 命令为你的应用创建一个 package.json 文件。 $ npm init 此命令将要求你输入几个参数，例如此应用的名称和版本。 你可以直接按“回车”键接受大部分默认设置即可。 接下来在 myapp 目录下安装 Express 并将其保存到项目的依赖列表中。如下： $ npm install express –save 创建index.js文件，并导入express： const express = require(‘express’); const app = express(); 123456789app.use(express.urlencoded()); // 解析application/x-www-form-urlencoded编码的数据app.use(express.json()); // 解析application/json编码的数据// 托管 public 目录下的静态资源app.use(express.static('public'));app.get('/', (req, res) =&gt; res.send('Hello World!'))app.listen(8080, () =&gt; console.log('Server running at port 8080')); 服务器配置server.js12345678910111213141516171819202122const express = require(\"express\") //导入expressconst app = express(); const bodyParser = require('body-parser') //导入body-parserconst students=require(\"./router/students.js\") //导入students.jsapp.use(bodyParser.urlencoded());app.use(express.static('public'))//设置请求头app.use(function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\") res.header(\"Content-Type\", \"application/json\") next()&#125;)app.use(\"/student\",students) //设置目录app.listen(8080, function () &#123; console.log(\"启动在8080端口\")&#125;) student.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091const express = require(\"express\")const router = express.Router()const fs = require(\"fs\") //导入fs文件管理系统const STUNENTSFILE = \"./../data/students.json\"const path = require(\"path\") //导入path路径系统//获取学生信息req: request //发送请求到服务器的数据在req.body中res: reponse //服务器返回数据router.get(\"/\", function (req, res) &#123; fs.readFile(path.join(__dirname, STUNENTSFILE), \"utf8\", function (err, data) &#123; if (err) throw err; res.status(200).send(data) &#125;)&#125;)//添加学生数据router.post(\"/adddata\", function (req, res) &#123; let students = &#123; \"ID\": Date.now(), \"name\": req.body.name, \"age\": req.body.age, \"tel\": req.body.tel, \"adress\": req.body.adress, \"hobby\": req.body.hobby, \"gander\": req.body.gander, \"oldtime\": new Date(), \"newtime\": new Date() &#125; fs.readFile(path.join(__dirname, STUNENTSFILE), \"utf8\", function (err, data) &#123; if (err) throw err; try &#123; data = JSON.parse(data) &#125; catch (error) &#123; return console.log(error) &#125; data.push(students) fs.writeFile(path.join(__dirname, STUNENTSFILE), JSON.stringify(data, null, 4), function (err) &#123; res.status(200).send(data) &#125;) &#125;)&#125;)//删除学生数据router.delete(\"/deldata\", function (req, res) &#123; fs.readFile(path.join(__dirname, STUNENTSFILE), \"utf8\", function (err, data) &#123; students = JSON.parse(data) let deleteindex = -1 if (err) throw err; students.forEach((student, index) =&gt; &#123; if (student.ID == req.body.ID) &#123; deleteindex = index &#125; &#125;) if (deleteindex &gt;= 0) &#123; students.splice(deleteindex, 1) &#125; fs.writeFile(path.join(__dirname, STUNENTSFILE), JSON.stringify(students, null, 4), function (err) &#123; res.status(200).send(\"删除成功\") &#125;) &#125;)&#125;)//修改学生数据router.put(\"/complete\", function (req, res) &#123; fs.readFile(path.join(__dirname, STUNENTSFILE), \"utf8\", function (err, data) &#123; students = JSON.parse(data) if (err) throw err; students.forEach((student) =&gt; &#123; if (student.ID == req.body.ID) &#123; student.name = req.body.name, student.age = req.body.age, student.tel = req.body.tel, student.adress = req.body.adress, student.gander = req.body.gander, student.newtime = new Date() &#125; &#125;) fs.writeFile(path.join(__dirname, STUNENTSFILE), JSON.stringify(students, null, 4), function (err) &#123; res.status(200).send(\"修改成功\") &#125;) &#125;)&#125;)exports = module.exports = router 前台HTMLhtml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;首页&lt;/title&gt; &lt;link rel=\"stylesheet\" href=\"./src/css/index.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;电话&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"newstudent\"&gt; &lt;tr&gt; &lt;td contenteditable=true&gt;&lt;/td&gt; &lt;td contenteditable=true&gt;&lt;/td&gt; &lt;td contenteditable=true&gt;&lt;/td&gt; &lt;td contenteditable=true&gt;&lt;/td&gt; &lt;td contenteditable=true&gt;&lt;/td&gt; &lt;td&gt;&lt;button class=\"remove\" click=\"savadata()\"&gt;保存&lt;/button&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;div id=\"student_list\"&gt; &lt;table &gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;ID&lt;/th&gt; &lt;th&gt;名字&lt;/th&gt; &lt;th&gt;年龄&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;电话&lt;/th&gt; &lt;th&gt;地址&lt;/th&gt; &lt;th&gt;修改时间&lt;/th&gt; &lt;th&gt;保存时间&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody id=\"studentsdata\"&gt;&lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.js\"&gt;&lt;/script&gt; &lt;script src=\"./src/js/index.js\"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; JS代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091 //获取数据function getdata() &#123; let gg = null $.get(\"/student\", function (response, success, xhr) &#123; for (var i = 0; i &lt; response.length; i++) &#123; gg += ('&lt;tr&gt;&lt;td&gt;' + response[i].ID + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].name + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].age + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].gander + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].tel + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].adress + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].newtime + '&lt;/td&gt;' + '&lt;td&gt;' + response[i].oldtime + '&lt;/td&gt;' + '&lt;td&gt;&lt;button class=\"amend\" &gt;修改&lt;/button&gt;' + '&lt;button class=\"deletedata\" &gt;删除&lt;/button&gt;&lt;/td&gt;' + '&lt;/tr&gt;') &#125; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; $('#studentsdata').html(gg) deletedata() savadata() complete() &#125; &#125;, 'json')&#125;getdata()//保存数据function savadata() &#123; $(\".remove\").click(function () &#123; var $nul = $(this).parent().siblings() var stundents = &#123; name: $nul.eq(0).text(), age: $nul.eq(1).text(), gander: $nul.eq(2).text(), tel: $nul.eq(3).text(), adress: $nul.eq(4).text(), &#125; $.post(\"/student/adddata\", stundents, function (response, success, xhr) &#123; getdata() &#125;) &#125;)&#125;//删除数据function deletedata() &#123; $(\".deletedata\").click(function () &#123; $.ajax(&#123; url: \"/student/deldata\", type: 'DELETE', data: &#123;ID:$(this).parent().siblings().eq(0).text()&#125;, success: function () &#123; getdata() &#125; &#125;) &#125;)&#125;//修改数据function complete() &#123; $(\".amend\").click(function () &#123; $(this).addClass(\"complete\").text(\"完成\") $(this).removeClass(\"amend\") $(this).parent().siblings().attr(\"contenteditable\", true) $(\".complete\").click(function () &#123; var $nul = $(this).parent().siblings() $(this).addClass(\"amend\").text(\"修改\") $(this).removeClass(\"complete\") $(this).parent().siblings().attr(\"contenteditable\", false) var stundents = &#123; ID: $nul.eq(0).text(), name: $nul.eq(1).text(), age: $nul.eq(2).text(), gander: $nul.eq(3).text(), tel: $nul.eq(4).text(), adress: $nul.eq(5).text(), &#125; $.ajax(&#123; url: \"/student/complete\", type: 'PUT', data: stundents, success: function () &#123; getdata() &#125; &#125;) &#125;) &#125;)&#125; 末尾啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊啊,还是有bug,弄一晚上还是出错出错出错。。。。 还是不会不会不会！！！！！！！啊啊啊啊啊啊啊啊 疯狂报错ing… 明天继续加油吧！！！ The Next Day欧耶，问题解决了。 主要的问题出现在后台返回的数据与服务器设置返回格式不一致导致的。 1234567app.use(bodyParser.urlencoded());app.use(express.static('public'))//设置请求头app.use(function (req, res, next) &#123; res.header(\"Access-Control-Allow-Origin\", \"*\") res.header(\"Content-Type\", \"application/json\") next()&#125;) 因为头部设置的服务器返回数据为JSON格式，但是在删除文件配置中最后返回的数据为字符串 123456789101112131415161718192021router.delete(\"/deldata\", function (req, res) &#123; fs.readFile(path.join(__dirname, STUNENTSFILE), \"utf8\", function (err, data) &#123; students = JSON.parse(data) let deleteindex = -1 if (err) throw err; students.forEach((student, index) =&gt; &#123; if (student.ID == req.body.ID) &#123; deleteindex = index &#125; &#125;) if (deleteindex &gt;= 0) &#123; students.splice(deleteindex, 1) &#125; fs.writeFile(path.join(__dirname, STUNENTSFILE), JSON.stringify(students, null, 4), function (err) &#123; res.status(200).send(\"删除成功\") //错误出现在这里。。。 res.status(200).send(&#123;message:\"删除成功\"&#125;) //正确的返回格式 &#125;) &#125;)&#125;) 但是,不知道为什么在修改数据中返回数据为字符串的时候回调函数还是执行了。 总之,服务器设置的返回格式一定一定要和服务器具体配置中返回的格式想用才能让回调函数正确执行。","path":"2019/01/09/node-js搭建服务器-1/","date":"01-09","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"利用gulp与npm创建自动化工具","text":"所需内容包查询地址 :https://gulpjs.com/plugins/gulp-less：将less文件内容编译成css内容。 gulp-cssnano：压缩css文件内容 gulp-htmlmin：压缩HTML文件内容 gulp-uglify：压缩混淆JS文件内容 gulp-connect：创建一个开发阶段所使用的服务器 这些方法都可以通过 npm/cnpm install 进行安装 特殊方法介绍gulp-htmlmin 链接:https://www.npmjs.com/package/connect12345678const gulp = require('gulp');const htmlmin = require('gulp-htmlmin'); gulp.task('minify', () =&gt; &#123; return gulp.src('src/*.html') .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(gulp.dest('dist'));&#125;); gulp-connect1234567891011121314151617181920212223242526var connect = require('connect');var http = require('http'); var app = connect(); // gzip/deflate outgoing responsesvar compression = require('compression');app.use(compression()); // store session state in browser cookievar cookieSession = require('cookie-session');app.use(cookieSession(&#123; keys: ['secret1', 'secret2']&#125;)); // parse urlencoded request bodies into req.bodyvar bodyParser = require('body-parser');app.use(bodyParser.urlencoded(&#123;extended: false&#125;)); // respond to all requestsapp.use(function(req, res)&#123; res.end('Hello from Connect!\\n');&#125;); //create node.js http server and listen on porthttp.createServer(app).listen(3000); 具体实现导入所需包12345const &#123; src, dest ,watch,series&#125; = require(\"gulp\")const htmlmin = require(\"gulp-htmlmin\");const uglify = require(\"gulp-uglify\")const cssnano = require(\"gulp-cssnano\")const connect=require(\"gulp-connect\") 压缩HTML网页1234567function htmlmini() &#123; return src(\"src/*.html\") .pipe(htmlmin(&#123; collapseWhitespace: true &#125;)) .pipe(dest(\"dest/\"))&#125; exports.htmlmn = htmlmini 压缩JS12345678function scriptmini() &#123; return src(\"src/*.js\") .pipe(uglify()) .pipe(dest(\"dest/\")) &#125; exports.scriptmn = scriptmini 压缩css1234567function cssmini() &#123; return src(\"src/*.css\") .pipe(cssnano()) .pipe(dest(\"dest/\")) &#125;exports.cssmn=cssmini 监听文件，被修改后调用方法1234567function watchfile(cb)&#123; watch(\"src/*.html\",htmlmini) watch(\"src/*.js\",scriptmini) watch(\"src/*.css\",cssmini) cb()&#125;exports.watch=watchfile 创建本地服务器123456789function serverauto(cb)&#123; connect.server(&#123; root: \"dest\", port: 4000, livereload:true &#125;) cb()&#125;exports.servermn=serverauto 当服务器与自动化任务创建完成之后就可以通过series方法绑定为默认方法。1exports.default =series(watchfile,serverauto) 所有的内容均在nood.js中执行文件，HTML/CSS/JS的编写在vscode中进行编辑，保存。 当方法没有return时，需要通过传入回调函数进行执行，否则会出错。","path":"2019/01/08/利用gulp与npm创建对网页内容的编辑刷新自动化/","date":"01-08","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"gulp :自动化构建工具","text":"gulp :自动化构建工具入门指南 全局安装 gulp： $ npm install --global gulp 作为项目的开发依赖（devDependencies）安装： $ npm install --save-dev gulp 在项目根目录下创建一个名为 gulpfile.js 的文件： var gulp = require(&apos;gulp&apos;); gulp.task(&apos;default&apos;, function() { // 将你的默认的任务代码放在这 }); 运行 gulp： $ gulp API文档：gulp.src(globs[, options]) 输出（Emits）符合所提供的匹配模式（glob）或者匹配模式的数组（array of globs）的文件。 将返回一个 Vinyl files 的 stream 它可以被 piped 到别的插件中。1234gulp.src('client/templates/*.jade') .pipe(jade()) .pipe(minify()) .pipe(gulp.dest('build/minified_templates')); 通俗来讲gulp就像一条生产线,src将需要生产的物品放进来,通过pipe()进行运输包装（pipe中调用的方法）,完成之后再通过最后的dest()放入产品的仓库。 常用的API有:src() :从文件系统中读取对象 dest() :将创建的文件写入文件系统 watch() :观察全局并在发生改变时运行任务 API具体网址：https://gulpjs.com/docs/en/api/concepts","path":"2019/01/07/gulp自动化构建工具/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"npm管理器","text":"NPM: NPM是随同NodeJS一起安装的包管理工具为了安装第三包，需要用nom管理器。第三方平台下载 : https://www.npmjs.com/ 安装npm :npm init 创建之后，在package.json中加入private：true代表设置为私人的包，并不会公众化。 安装第三方包npm install --global http-server 安装全局http命令。 默认为最新版本，在server后@可设置版本号。 npm uninstall --global http-server 卸载全局http命令 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录。 可以直接在命令行里使用。 npm install –global gulp安装本地包 将安装包放在 ./node_modules 下（运行 npm 命令时所在的目录），如果没有 node_modules 目录，会在当前执行 npm 命令的目录下生成 node_modules 目录。 可以通过 require() 来引入本地安装的包。 npm install gulp –save-dev/-D 适用于开发阶段的包 –save 适用于开发和产品阶段 卸载模块我们可以使用以下命令来卸载 Node.js 模块。 $ npm uninstall express卸载后，你可以到 /node_modules/ 目录下查看包是否还存在，或者使用以下命令查看： $ npm ls 更新模块我们可以使用以下命令更新模块： $ npm update express 搜索模块使用以下来搜索模块： $ npm search express 创建模块创建模块，package.json 文件是必不可少的。我们可以使用 NPM 生成 package.json 文件，生成的文件包含了基本的结果。1234567891011121314151617181920212223242526272829303132$ npm initThis utility will walk you through creating a package.json file.It only covers the most common items, and tries to guess sensible defaults.See `npm help json` for definitive documentation on these fieldsand exactly what they do.Use `npm install &lt;pkg&gt; --save` afterwards to install a package andsave it as a dependency in the package.json file.Press ^C at any time to quit.name: (node_modules) runoob # 模块名version: (1.0.0) description: Node.js 测试模块(www.runoob.com) # 描述entry point: (index.js) test command: make testgit repository: https://github.com/runoob/runoob.git # Github 地址keywords: author: license: (ISC) About to write to ……/node_modules/package.json: # 生成地址&#123; \"name\": \"runoob\", \"version\": \"1.0.0\", \"description\": \"Node.js 测试模块(www.runoob.com)\", ……&#125;Is this ok? (yes) yes以上的信息，你需要根据你自己的情况输入。在最后输入 \"yes\" 后会生成 package.json 文件。 注册用户（使用邮箱注册）：$ npm adduserUsername: mcmohdPassword:Email: (this IS public) mcmohd@gmail.com 发布模块：$ npm publish如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。 NPM 常用命令除了本章介绍的部分外，NPM还提供了很多功能，package.json里也有很多其它有用的字段。 NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。 使用npm help 可查看某条命令的详细帮助，例如npm help install。 在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。 使用npm update 可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。 使用npm update -g可以把全局安装的对应命令行程序更新至最新版。 使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。 使用npm unpublish @可以撤销发布自己发布过的某个版本代码。 解决服务器在国外下载慢的问题。方法一淘宝定制命令行工具 npm install -g cnpm --registry=https://registry.npm.taobao.org 方法二修改npm的下载仓库为淘宝镜像 npm config set registry http://registry.npm.taobao.org/ 如果要发布自己的镜像需要修改回来 npm config set registry https://registry.npmjs.org/","path":"2019/01/07/npm第三方包管理器/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"Commonjs规范","text":"Commonjs规范介绍：CommonJS定义的模块分为: 1.模块引用(require) 2.模块定义(exports) 3.模块标识(module) CommonJs规范的出发点：JS没有模块系统、标准库较少、缺乏包管理工具；为了让JS可以在任何地方运行，以达到Java、C#、PHP这些后台语言具备开发大型应用的能力； 在CommonJs规范中：1一个文件就是一个模块，拥有单独的作用域； 2普通方式定义的变量、函数、对象都属于该模块内； 3通过require来加载模块； 4通过exports和modul.exports来暴露模块中的内容； ps :所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；模块的加载顺序，按照代码的出现顺序是同步加载的; exports 导出require 导入每个模块内部都有一个module对象，代表当前对象。 123456exports.multiply = function(num1, num2) &#123; return num1 * num2; &#125;exports.divide = function(num1, num2) &#123; return num1 / num2; &#125; module变量： 每个模块内部都有一个module对象，代表着当前模块。它有以下属性： 12345console.log(module.id) // 模块的标识符，通常是带有绝对路径的模块文件名 console.log(module.filename) // 模块文件名，带有绝对路径 console.log(module.parent) // 调用该模块的模块 console.log(module.chilren) // 该模块调用的模块 console.log(module.exports) // 表示模块对外导出的值 exports变量： 为了方便，Node为每个模块提供了exports变量，指向module.exports， 等同于： var exports = module.exports（Node隐式做了这个赋值） 这样做的好处是，在对外输出模块接口时，可以向exports对象添加方法暴露出去。因此如果改变了module.exports，但还想使用export.xxx的方式暴露一些东西，那就只好我们自己来写exports = module.exports; console.log(exports)123module.exports = songthing;//接下来把exports指回来exports = module.exports;//常见写法是：exports = module.exports = something; 基本用法导出module1.js模块中内容： 1234567exports.multiply = function(num1, num2) &#123;return num1 * num2;&#125;exports.divide = function(num1, num2) &#123;return num1 / num2;&#125; 导入module1.js模块中的内容： 123456const module1 = require(&apos;./module1.js&apos;);console.log(module1.multiply(3, 4))console.log(module1.divide(12, 4))&#125; 常用命令已经标识符__dirname代表当前模块文件所在的文件夹路径 __filename代表当前模块文件所在的文件夹路径+文件名 npm root -g：查看npm全局包安装位置，建议在nvm目录下新建npm\\node_modules目录，然后设置npm的全局包安装位置：npm config set prefix “”，然后将该路径添加到环境变量中; npm init -y：初始化一个package.json文件，加上-y就会默认生成该文件，无需一步一步填写；npm docs 包名：查看包的文档；npm install：安装package.json中dependencies属性中所有依赖的包","path":"2019/01/07/Commonjs规范/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"node.js简单介绍","text":"介绍简单的说 Node.js 就是运行在服务端的 JavaScript。 Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。 Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。 中文API文档： http://nodejs.cn/api/英文API文档: https://nodejs.org/en/docs/命令与特殊键1234567891011121314node 进入交互式解析node --help 帮助信息node -v 版本信息-e 执行JS代码.break 终止正在输入的表达式.load 读取一个文件到当前会话.editor 进入编辑模式","path":"2019/01/07/node-js介绍/","date":"01-07","excerpt":"","tags":[{"name":"node.js","slug":"node-js","permalink":"https://bmmanmyt.github.io/tags/node-js/"}]},{"title":"箭头函数","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;pre style=\"color:red\"&gt; // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ &lt;/pre&gt; &lt;script&gt; /* **************************************************************** */ /* var 声明的变量会被提升，多次声明时会被覆盖。 let 声明的变量不会被提升，不可以多次声明，作用于只存在于块。 */ /* **************************************************************** */ // 使用const可以声明常量，常量不可以被更改。 /* **************************************************************** */ // 函数参数的默认值，当函数不传入参数时显示的默认值 function MY(name = \"李四\", age = \"20\") &#123; return name + age &#125; console.log(MY()) console.log(MY(\"王五\", \"15\")) /* **************************************************************** */ // 箭头函数 // 箭头函数中没有this，this的指向是windows var num = (a, b) =&gt; a + b //有两个参数 console.log(num(3, 4)) var a = () =&gt; \"hi\" //没有参数 console.log(a()) var b = name =&gt; name //只有一个参数 console.log(b(\"渣男\")) var num2 = (c, d) =&gt; c &gt; d ? c : d //两个数比较大小 console.log(num2(5, 7)) /* **************************************************************** */ //剩余操作符(...) //1.用于传入参数时不知道参数个数。 var e = (...f) =&gt; f console.log(e(1, 2, 3, 4, 5, 6, 7, 8, 9)) //测试，乘 加： var resule = (operator, ...numall) =&gt; &#123; if (operator === \"+\") &#123; let resule1 = 0 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 += numall[i] &#125; return resule1 &#125; if (operator === \"*\") &#123; let resule1 = 1 for (let i = 0; i &lt; numall.length; i++) &#123; resule1 *= numall[i] &#125; return resule1 &#125; &#125; console.log(resule(\"+\", 1, 2, 3, 4)) console.log(resule(\"*\", 1, 2, 3, 4)) //2.用于展开数组 let arr1 = [1, 2, 3, 4, 5, 67, 8, 9, 7] console.log(...arr1) // 3.复制数组 let arr2 = [...arr1] console.log(arr2) /* **************************************************************** */ // 模板字面量 console.log(` --------------- --------------- || || --------------- --------------- || || --------------- --------------- 中间拼接变量时用$() `) console.log(` // \\\\ // \\\\ // ##DDDDDDDDDDDDDDDDDDDDDD## ## DDDDDDDDDDDDDDDDDDDD ## ________ ___ ___ ___ ________ ___ ___ ___ ## hh hh ## |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ |\\ __ \\ |\\ \\ |\\ \\ |\\ \\ ## hh // \\\\ hh ## \\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ \\|\\ /_\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh // \\\\ hh ## \\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\\\ \\ __ \\\\ \\ \\\\ \\ \\ \\ \\ \\ ## hh hh ## \\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\\\ \\ \\|\\ \\\\ \\ \\\\ \\ \\____ \\ \\ \\ ## hh wwww hh ## \\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\\\ \\_______\\\\ \\__\\ ## hh hh ## \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| \\|_______| \\|__| ## MMMMMMMMMMMMMMMMMMMM ## ##MMMMMMMMMMMMMMMMMMMMMM## Release 2.5.1. Powered by jinkela-core 2.3.1. \\/ \\/ `) /* **************************************************************** */ // 对象属性的简写 // 对象的属性名字==属性值的时候，可以只写一个。 let g = \"渣男\" var obj = &#123; g &#125; console.log(obj.g) /* **************************************************************** */ //数据解构 let munber = [1, 2, 3, 4, 56, 7, 8, 9, 5] let [one, ...two] = munber console.log(one, two) let munber2 = [1, 2, 3, [4, 56, 7], 8, 9, 5] let [, , , [thiree]] = munber2 console.log(thiree) /* **************************************************************** */ //对象解构 let h = &#123; name: \"mengmeng\" &#125; let &#123; name &#125; = h console.log(name) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","path":"2019/01/05/箭头函数/","date":"01-05","excerpt":"","tags":[{"name":"ES6新特性","slug":"ES6新特性","permalink":"https://bmmanmyt.github.io/tags/ES6新特性/"}]},{"title":"JavaScript 简答题","text":"请描述一下cookies，sessionStorage和localStorage的区别？sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。但是Cookie也是不可以或缺的：Cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生。 看下列代码输出为何？解释原因。123var a;alert(typeof a); // undefinedalert(b); // 报错 用js实现随机选取10–100之间的10个数字，存入一个数组，并排序。1234567891011121314151617181920212223function randomNub(aArray, len, min, max) &#123; if (len &gt;= (max - min)) &#123; return '超过' + min + '-' + max + '之间的个数范围' + (max - min - 1) + '个的总数'; &#125; if (aArray.length &gt;= len) &#123; aArray.sort(function(a, b) &#123; return a - b &#125;); return aArray; &#125; var nowNub = parseInt(Math.random() * (max - min - 1)) + (min + 1); for (var j = 0; j &lt; aArray.length; j++) &#123; if (nowNub == aArray[j]) &#123; randomNub(aArray, len, min, max); return; &#125; &#125; aArray.push(nowNub); randomNub(aArray, len, min, max); return aArray; &#125;var arr=[];randomNub(arr,10,10,100); 如何阻止事件冒泡和默认事件阻止事件冒泡：1234.stopPropagation();// 阻止默认事件return false;.preventDefault(); JavaScript的数据类型都有什么？看下列代码，将会输出什么?(变量声明提升)123456var foo = 1;(function()&#123; console.log(foo); // undefined var foo = 2; console.log(foo); // 2&#125;)() 怎样添加、移除、移动、复制、创建和查找节点。正则表达式构造函数var reg=new RegExp(“xxx”)与正则表达字面量var reg=//有什么不同？匹配邮箱的正则表达式？当使用RegExp()构造函数的时候，不仅需要转义引号（即\\”表示”），并且还需要双反斜杠（即\\表示一个\\）。使用正则表达字面量的效率更高。邮箱的正则匹配： var regMail = /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]{2,3}){1,2})$/; 一个完整的URL有哪几部分组成？1.协议部分：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“//”为分隔符。 2.域名部分：该URL的域名部分为“www.haogu.com”。一个URL中，也可以使用IP地址作为域名使用。 3.端口部分：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口80 4.虚拟目录部分：从域名后的第一个“/”开始到最后一个“/”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“/news/” 5.文件名部分：从域名后的最后一个“/”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“/”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“/”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名。 6.锚部分：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分。 7.参数部分：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“username=lisi&amp;password=24618&amp;page=1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。 请求消息和相应消息分别有哪几本部分组成？客户端发送给服务器端的HTTP请求消息由请求行（request line）、请求头部（header）、空行和请求数据四个部分组成，如下图所示。 123456789GET /index.html HTTP/1.1 Host: www.baidu.com Connection: keep-alive Upgrade-Insecure-Requests: 1 User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie:BAIDUID=002E605A2EE0AA27D0B7C2295B9D0242:FG=1;BIDUPSID=002E605A2EE0AA27D0B7C2295B9D0242;PSTM=1532306024;BD_UPN=12314753;BDORZ=B490B5EBF6F3CD402E515D22BCDA1598;delPer=0;BD_HOME=0;H_PS_PSSID=1465_26911_21121_26350_26925_20719 第一部分：请求行，用来说明请求类型，要访问的资源以及所使用的HTTP版本. 请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本。GET指定请求类型为GET，/index.html为要访问的资源，该行的最后一部分说明使用的是HTTP1.1版本。 第二部分：请求头部，紧接着请求行（即第一行）之后的部分，用来说明服务器要使用的附加信息。 从第二行起为请求头部，HOST将指出请求的目的地。User-Agent，服务器端和客户端脚本都能访问它,它是浏览器类型检测逻辑的重要基础.该信息由你的浏览器来定义,并且在每个请求中自动发送等等。 第三部分：空行，请求头部后面的空行是必须要有的 即使第四部分的请求数据为空，也必须有空行。 第四部分：请求数据也叫主体，可以添加任意的其他数据。 这个例子的请求数据为空。 POST请求例子，使用Charles抓取的request：123456789101112131415POST /api/students HTTP/1.1 Host: 192.168.0.130:3000 Connection: keep-alive Content-Length: 245 Cache-Control: max-age=0 Origin: http://192.168.0.130:3000 Upgrade-Insecure-Requests: 1 Content-Type: application/x-www-form-urlencoded User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36 Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Referer: http://192.168.0.130:3000/students/create Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9clazz=%E7%81%AB%E8%8A%B112%E6%9C%9F&amp;name=%E9%99%88%E6%A2%A6%E9%BE%99&amp;gender=%E7%94%B7&amp;age=20&amp;hobby=%E7%9D%A1%E8%A7%89&amp;hobby=%E6%89%93%E8%B1%86%E8%B1%86&amp;tel=13834569928&amp;address=%E5%8D%97%E9%98%B3&amp;remark=%E6%96%B0%E5%90%8C%E5%AD%A6&amp;date=2018-08-01 第一部分：请求行，第一行明了是post请求，以及http1.1版本。第二部分：请求头部，第二行至第六行。第三部分：空行，第七行的空行。第四部分：请求数据，第八行。 响应消息Response一般情况下，服务器接收到请求后，会对请求进行处理，然会返回给客户端一个HTTP的响应消息。HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文。1234567891011121314151617181920212223242526272829HTTP/1.1 200 OK Bdpagetype: 1 Bdqid: 0xc347763400004282 Cache-Control: private Connection: Keep-Alive Content-Encoding: gzip Content-Type: text/html Cxy_all: baidu+5e802392ce41b42ad2771898f1006759 Date: Thu, 09 Aug 2018 01:36:14 GMT Expires: Thu, 09 Aug 2018 01:36:06 GMT Server: BWS/1.1 Set-Cookie: delPer=0; expires=Sat, 01-Aug-2048 01:36:06 GMT Set-Cookie: BDSVRTM=0; path=/ Set-Cookie: BD_HOME=0; path=/ Set-Cookie: H_PS_PSSID=1465_26964_21121_26350_26925_20719;path=/;domain=.baidu.com Strict-Transport-Security: max-age=172800 Vary: Accept-Encoding X-Ua-Compatible: IE=Edge,chrome=1 Transfer-Encoding: chunked&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;title&gt;百度一下&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 文档内容。。。&lt;/body&gt;&lt;/html&gt; 第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。 第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok） 第二部分：消息报头，用来说明客户端要使用的一些附加信息 第二行和第三行为消息报头，Date:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8 第三部分：空行，消息报头后面的空行是必须的 第四部分：响应正文，服务器返回给客户端的文本信息。 空行后面的html部分为响应正文。 HTTP协议的工作原理？HTTP请求的方式有几种？分别表示什么意义？有 8 种；HTTP 1.0 提供了 GET，POST，HEAD；HTTP 1.1 有新增了 OPTIONS，PUT，DELETE，CONNECT，TRACE Ajax 的作用是什么? 如何创建一个Ajax？作用：用于浏览器与服务器进行数据交互，实现页面的局部刷新。 ######## 创建一个Ajax请求：12345678Var request = XMLHttpRequest();request.open(‘POST’, url, true); // 默认是异步请求request.onreadystatechange = function()&#123;&#125;;// 设置请求头request.setRequestHeader(‘Content-Type’, ‘application/x-www-form-urlencoded’);request.send(null); 举例描述同步和异步的区别？同步:发送一个请求,等待返回,然后再发送下一个请求异步:发送一个请求,不等待返回,随时可以再发送下一个请求 请简述一下什么是同源策略？同源策略浏览器采用同源策略，禁止页面加载或执行与自身来源不同的域的任何脚本。换句话说浏览器禁止的是来自不同源的”document”或脚本，对当前”document”读取或设置某些属性。 什么是同源URL由协议、域名、端口和路径组成，如果两个URL的协议、域名和端口相同，则表示他们同源。相反，只要协议，域名，端口有任何一个的不同，就被当作是跨域。 如何解决跨域问题？1.JSONP2.通过服务器进行设置3.使用代理服务器 请简述GET和POST请求的区别，以及它们的使用场景？安全性GET 请求会将传输数据拼接在 URL 中，并显示在浏览器地址栏中。而POST相对来说比较安全，传输的数据会被放到请求体中。 传输速度GET请求会被POST请求快一些。 传输数据量GET请求能传输的数据量比较小，因不同的浏览器而有所不同，大概 4KB左右；而POST请求能传输的数据理论上没有上限的，但由于服务器硬件资源的限制，能传输的数据量也会受影响。有时候服务器的设置也会影响能传输的数据量。 在进行Ajax请求时，如何解析请求返回的json数据使用JSON.parse()方法将json格式的字符串转换成对象（Array或Object）列举出你学过的JavaScript本地对象，内置对象和宿主对象本地对象：Object, Array,Date内置对象：global,Math宿主对象：DOM，BOM 请分别描述引用类型的数据和基本类型的数据在内存中的存储方式？基本类型的数据直接存储在变量的存储空间中；而引用类型的数据并没直接存储在变量的存储空间中，变量中存储的只是引用类型数据所在的内存地址。 在使用new操作符调用函数时，具体发生了什么事（new操作符的作用）?当我们使用 new 操作符调用函数时，函数内部会自动创建一个该类型的新对象，新对象的原型指向构造函数的prototype属性。当函数调用完成时，该对象会被自动的返回到函数外部。我们可以在函数内部通过 this 关键字使用新创建的对象。 对象的属性有几种类型？怎么定义这些属性？有 2 种，分别是：数据属性和访问器属性；定义属性的方式如下：123456789101112131415161718192021Var obj1 = &#123;Name: ‘张铭恩’Age: 20,Get adult() &#123;Return this.age &gt;= 18 ? true : false;&#125;&#125;Var obj2 = &#123;Name: ‘张铭恩’Age: 20,Count: 20000Get money() &#123;Return this.count / 100;&#125;,Set money(income) &#123;This.count = this.count + income * 100;&#125;&#125;Obj2.money; // 200;// 收入300Obj2.money = 300; 属性的特性有哪些？分别代表什么意思？数据属性的特性：value 属性值Writable 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除访问器属性的特性：Get 是否可以访问Set 是否可以修改Enumerable 是否可以枚举Configurable 是否可以删除 怎样获取属性的特性？怎样设置属性的特性？获取属性的特性：getOwnPropertyDescriptor()getOwnPropertyDescriptors()设置属性的特性:defineProperty()defineProperties() 怎样封印、冻结和禁止对象扩展？禁止扩展：preventExtensions();封印对象：seal()冻结对象：freeze()被禁止扩展对象、被封印对象和被冻结对象有什么特点？被禁止扩展对象的特点： 不能添加新属性（不可扩展） 可以删除已有属性 可以修改已有属性的值 被封印对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 可以修改已有属性的值被冻结对象的特点： 不能添加新属性（不可扩展） 不能删除已有属性 不能修改已有属性的值请简述对象属性的查找顺序？当我方法对象的属性时，JavaScript引擎首先会去对象自身的属性列表种查询，如果有，则返回；如果没有，则沿着原型对象链向下寻找。如果整个原型对象链中都没有，则返回 undefined。对象的继承方式有几种？请分别编程实现：3 种，分别是：原型对象继承、对象继承、构造函数继承；12345678910111213141516171819202122232425262728293031323334原型继承（JS默认继承方式）：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;var rect = new Rectangle(40, 20);rect 对象默认继承了 Rectangle.prototype，间接继承了 Object.prototype。对象继承：var obj1 = &#123;...&#125;;var obj2 = Object.create(obj1, &#123;...&#125;);obj2 继承了 obj1，obj1继承 Object.prototype。构造函数继承：function Rectangle(w, h)&#123;this.width = w;this.height = h;&#125;Object.defineProperty(Rectangle.prototype, ‘getArea’, &#123;value: function()&#123;return this.width * this.height;&#125;Writable: false,Enumerable: false,Configurable: false&#125;);function Square(w)&#123;this.width = w;this.height = w;&#125;Square.prototype = Object.create(new Rectangle(), &#123;constructor: &#123;value: Square,configurable: false,enumerable: false,writable: false&#125;&#125;&#125;;","path":"2019/01/04/JavaScript-简答题/","date":"01-04","excerpt":"","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://bmmanmyt.github.io/tags/JavaScript/"}]}]}